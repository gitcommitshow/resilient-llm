<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ResilientLLM - Playground</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- 
        Simple Chat UI demonstrating ResilientLLM integration
        
        ResilientLLM handles all the complexity:
        - Rate limiting (requests per minute, tokens per minute)
        - Automatic retries with exponential backoff
        - Circuit breaker for service resilience
        - Token estimation
        - Error handling and recovery
    -->
    <div class="chat-container">
        <div class="playground-header">
            <div>
                <h1>ResilientLLM Playground</h1>
                <p>Experiment with prompts, models, and resilience</p>
            </div>
            <div class="header-right">
                <div class="status-bar" id="statusBar">
                    <span class="status-label">Service:</span>
                    <span id="statusService">—</span>
                    <span class="status-separator">•</span>
                    <span class="status-label">Model:</span>
                    <span id="statusModel">—</span>
                    <span class="status-separator">•</span>
                    <span class="status-label">Mode:</span>
                    <span id="statusMode">Text</span>
                </div>
                <button class="icon-button" id="settingsToggleButton" title="Playground settings">
                    ☰
                </button>
            </div>
        </div>

        <div class="playground-main">
            <!-- Prompts Sidebar -->
            <aside class="sessions-sidebar" id="promptsSidebar">
                <div class="sessions-header">
                    <h2>Prompts</h2>
                    <button class="new-session-btn" id="newPromptButton" title="New prompt">+ New</button>
                </div>
                <div class="sessions-list" id="promptsList">
                    <!-- Prompts will be dynamically populated here -->
                </div>
            </aside>

            <!-- Chat panel -->
            <section class="chat-panel">
                <!-- Prompt Header with Versions and Conversations -->
                <div class="prompt-header-panel" id="promptHeader" style="display: none;">
                    <div class="prompt-title-bar">
                        <h3 class="prompt-name-display" id="promptNameDisplay" contenteditable="true" title="Click to edit prompt name">New Prompt</h3>
                        <button class="save-version-btn" id="saveVersionButton" title="Save current conversation as a version">Save Version</button>
                    </div>
                    <div class="versions-drafts-bar">
                        <div class="versions-section">
                            <span class="section-label">Versions:</span>
                            <div class="versions-container" id="versionsContainer">
                                <!-- Versions will be populated here -->
                            </div>
                        </div>
                        <div class="conversations-section">
                            <span class="section-label">Conversations:</span>
                            <div class="conversations-container" id="conversationsContainer">
                                <!-- Conversations will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>

                <div class="system-prompt-pinned" id="systemPromptPinned">
                    <div class="system-prompt-pinned-header" id="systemPromptHeader">
                        <div class="system-prompt-pinned-header-left">
                            <span class="system-prompt-pinned-label">System Prompt</span>
                            <span class="system-prompt-preview" id="systemPromptPreview"></span>
                        </div>
                        <span class="system-prompt-pinned-toggle" id="systemPromptToggle">▼</span>
                    </div>
                    <div class="system-prompt-pinned-content" id="systemPromptContent" style="display: none;">
                        <div class="system-prompt-pinned-display" id="systemPromptDisplay"></div>
                    </div>
                </div>
                <div class="messages-container" id="messagesContainer">
                    <div class="empty-state" id="emptyState">
                        <div class="empty-state-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                        <div class="empty-state-text">
                            <strong>Start a conversation</strong><br>
                            Configure the playground on the right, then send a message to begin.
                        </div>
                    </div>
                </div>

                <div class="resilience-panel" id="resiliencePanel">
                    <div class="resilience-header">
                        <span class="resilience-title">Resilience & call details</span>
                        <span class="resilience-hint">Will show retries, fallbacks, and errors when connected.</span>
                    </div>
                    <div class="resilience-body" id="resilienceBody">
                        <p>Select an assistant message to inspect its call chain once backend data is available.</p>
                    </div>
                </div>

                <div class="input-role-bar">
                    <span class="input-role-label">Send as:</span>
                    <div class="role-toggle" id="roleToggle">
                        <button type="button" data-role="user" class="role-toggle-btn active">User</button>
                        <button type="button" data-role="assistant" class="role-toggle-btn">Assistant</button>
                    </div>
                </div>

                <div class="input-container">
                    <div class="input-main">
                        <textarea 
                            class="input-field" 
                            id="messageInput" 
                            placeholder="Type your message..."
                            autocomplete="off"
                            rows="1"
                        ></textarea>
                        <button class="send-button" id="sendButton" title="Send message">
                            ➤
                        </button>
                    </div>
                </div>
            </section>
        </div>
        
        <div class="library-footer" id="libraryFooter">
            <span class="library-footer-text">
                Made with <a href="https://github.com/gitcommitshow/resilient-llm" target="_blank" rel="noopener noreferrer" class="library-name-link"><strong>ResilientLLM</strong></a> <span id="libraryVersion">v1.1.0</span>
                <a href="#" id="librarySourceLink" class="library-source-link" target="_blank" rel="noopener noreferrer">
                    <span id="librarySource">npm</span>
                </a>
            </span>
        </div>
    </div>

    <!-- Settings drawer -->
    <div class="settings-drawer-backdrop" id="settingsBackdrop"></div>
    <aside class="settings-drawer" id="settingsDrawer" aria-hidden="true">
        <div class="settings-drawer-header">
            <div>
                <h2>Playground settings</h2>
                <p>Optional configuration for prompts, models, and sessions.</p>
            </div>
            <button class="icon-button" id="settingsCloseButton" title="Close settings">
                ×
            </button>
        </div>
        <div class="settings-drawer-body">
            <div class="config-panel">
                <section class="config-section">
                    <div class="config-section-header">
                        <h2>Model & service</h2>
                    </div>
                    <div class="config-field">
                        <label for="serviceSelect">Service</label>
                        <select id="serviceSelect">
                            <option value="">Select service</option>
                            <option value="openai">OpenAI</option>
                            <option value="anthropic">Anthropic</option>
                            <option value="gemini">Google</option>
                            <option value="local">Local / Other</option>
                        </select>
                    </div>
                    <div class="config-field">
                        <label for="modelSelect">Model</label>
                        <input
                            id="modelSelect"
                            type="text"
                            placeholder="e.g. gpt-4.1-mini"
                        />
                    </div>
                    <div class="config-field">
                        <label for="apiKeyInput">API Key</label>
                        <input
                            id="apiKeyInput"
                            type="password"
                            placeholder="Enter API key for selected service"
                            autocomplete="off"
                        />
                        <small class="config-hint">Stored locally in your browser. Leave empty to use environment variable.</small>
                    </div>

                    <details class="config-advanced">
                        <summary>Advanced options</summary>
                        <div class="config-advanced-grid">
                            <div class="config-field">
                                <label for="temperatureInput">Temperature</label>
                                <input id="temperatureInput" type="number" step="0.1" min="0" max="2" placeholder="1.0" />
                            </div>
                            <div class="config-field">
                                <label for="maxTokensInput">Max tokens</label>
                                <input id="maxTokensInput" type="number" min="1" placeholder="e.g. 512" />
                            </div>
                            <div class="config-field">
                                <label for="topPInput">top_p</label>
                                <input id="topPInput" type="number" step="0.05" min="0" max="1" placeholder="1.0" />
                            </div>
                            <div class="config-field config-field-inline">
                                <label for="streamingToggle">Streaming</label>
                                <input id="streamingToggle" type="checkbox" />
                            </div>
                        </div>
                        <p class="config-hint">These options are visual-only until wired to the backend.</p>
                    </details>
                </section>

                <section class="config-section">
                    <div class="config-section-header">
                        <h2>Response mode</h2>
                    </div>
                    <div class="mode-toggle" id="modeToggle">
                        <button type="button" data-mode="text" class="mode-toggle-button mode-toggle-button-active">Text</button>
                        <button type="button" data-mode="json" class="mode-toggle-button">JSON (structured)</button>
                    </div>
                    <textarea
                        id="jsonSchemaInput"
                        class="json-schema-input"
                        rows="3"
                        placeholder="Optional: describe expected JSON shape or paste a simple schema. Used for display only right now."
                    ></textarea>
                </section>

            </div>
        </div>
    </aside>

    <!-- Markdown rendering library -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    
    <!-- Application modules -->
    <script src="api.js"></script>
    <script src="sessions.js"></script>
    <script src="messages.js"></script>
    <script src="ui.js"></script>
    
    <!-- Main application logic -->
    <script>
        // Initialize application
        const messagesContainer = document.getElementById('messagesContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const roleToggle = document.getElementById('roleToggle');
        const emptyState = document.getElementById('emptyState');
        const modeToggle = document.getElementById('modeToggle');
        const statusService = document.getElementById('statusService');
        const statusModel = document.getElementById('statusModel');
        const statusMode = document.getElementById('statusMode');
        const serviceSelect = document.getElementById('serviceSelect');
        const modelSelect = document.getElementById('modelSelect');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const temperatureInput = document.getElementById('temperatureInput');
        const maxTokensInput = document.getElementById('maxTokensInput');
        const topPInput = document.getElementById('topPInput');
        const settingsToggleButton = document.getElementById('settingsToggleButton');
        const settingsCloseButton = document.getElementById('settingsCloseButton');
        const settingsDrawer = document.getElementById('settingsDrawer');
        const settingsBackdrop = document.getElementById('settingsBackdrop');
        
        let messages = [];
        let isAIResponding = false;
        let defaultsLoaded = false;
        
        // API Key management (localStorage only)
        const API_KEYS_STORAGE_KEY = 'resilientllm_api_keys';
        
        function loadApiKeys() {
            try {
                const stored = localStorage.getItem(API_KEYS_STORAGE_KEY);
                return stored ? JSON.parse(stored) : {};
            } catch {
                return {};
            }
        }
        
        function saveApiKey(service, key) {
            const keys = loadApiKeys();
            if (key && key.trim()) {
                keys[service] = key.trim();
            } else {
                delete keys[service];
            }
            localStorage.setItem(API_KEYS_STORAGE_KEY, JSON.stringify(keys));
        }
        
        function getApiKeyForService(service) {
            const keys = loadApiKeys();
            return keys[service] || '';
        }
        
        // Expose messages globally for message functions
        window.playgroundMessages = messages;
        
        // Undo system
        window.playgroundUndoStack = [];
        
        // Track currently editing message (single edit mode)
        window.currentlyEditingMessageId = null;

        window.playgroundState = {
            responseMode: 'text',
            senderRole: 'user'  // 'user' or 'assistant'
        };

        /**
         * Collect current LLM settings from UI and build llmOptions object
         */
        function collectLLMOptions() {
            const options = {};
            
            const service = serviceSelect.value;
            const actualService = service === 'local' ? 'ollama' : service;
            if (service) {
                options.aiService = actualService;
            }
            
            if (actualService) {
                const apiKey = getApiKeyForService(actualService);
                if (apiKey) {
                    options.apiKey = apiKey;
                }
            }
            
            const model = modelSelect.value.trim();
            if (model) {
                options.model = model;
            }
            
            const temperature = temperatureInput.value.trim();
            if (temperature) {
                const tempValue = parseFloat(temperature);
                if (!isNaN(tempValue)) {
                    options.temperature = tempValue;
                }
            }
            
            const maxTokens = maxTokensInput.value.trim();
            if (maxTokens) {
                const maxTokensValue = parseInt(maxTokens, 10);
                if (!isNaN(maxTokensValue) && maxTokensValue > 0) {
                    options.maxTokens = maxTokensValue;
                }
            }
            
            const topP = topPInput.value.trim();
            if (topP) {
                const topPValue = parseFloat(topP);
                if (!isNaN(topPValue)) {
                    options.topP = topPValue;
                }
            }
            
            if (window.playgroundState.responseMode === 'json') {
                if (actualService === 'openai' || actualService === 'ollama' || actualService === 'gemini') {
                    options.responseFormat = { type: 'json_object' };
                } else if (actualService === 'anthropic') {
                    options.responseFormat = { type: 'json_object' };
                }
            }
            
            return options;
        }

        /**
         * Trigger AI response for the current conversation
         */
        async function triggerAIResponse(regenerate = false) {
            if (isAIResponding) return;
            
            if (regenerate) {
                const lastMessage = messages[messages.length - 1];
                if (lastMessage && lastMessage.role === 'assistant') {
                    messages.pop();
                    window.playgroundMessages = messages;
                    const messageDiv = messagesContainer.querySelector(`[data-message-id="${lastMessage.id}"]`);
                    if (messageDiv) {
                        messageDiv.remove();
                    }
                }
            }
            
            const lastMessage = messages[messages.length - 1];
            if (!lastMessage || lastMessage.role !== 'user') {
                return;
            }
            
            isAIResponding = true;
            messageInput.disabled = true;
            sendButton.disabled = true;

            showTypingIndicator(messagesContainer);

            try {
                const conversationHistory = buildConversationHistory(messages);
                const llmOptions = collectLLMOptions();
                
                const aiResponse = await getAIResponse(conversationHistory, llmOptions);
                
                hideTypingIndicator();
                addMessage(aiResponse, 'assistant', messages, messagesContainer, emptyState);
                window.playgroundMessages = messages;
                
                autoSaveConversationState();
            } catch (error) {
                hideTypingIndicator();
                const errorMessage = error.message || 'Failed to get response from AI. Please check if the server is running and your API key is set.';
                addMessage(`Error: ${errorMessage}`, 'assistant', messages, messagesContainer, emptyState);
                window.playgroundMessages = messages;
                console.error('Error sending message:', error);
                
                autoSaveConversationState();
            } finally {
                isAIResponding = false;
                messageInput.disabled = false;
                sendButton.disabled = false;
                messageInput.focus();
                autoResizeTextarea(messageInput);
            }
        }

        /**
         * Send a message to the AI assistant
         */
        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || isAIResponding) return;

            // Ensure prompt and conversation exist
            ensurePromptAndConversation();

            const role = window.playgroundState.senderRole;
            addMessage(text, role, messages, messagesContainer, emptyState);
            window.playgroundMessages = messages;
            messageInput.value = '';
            autoResizeTextarea(messageInput);
            
            autoSaveConversationState();
            
            // Only trigger AI response for user messages
            if (role === 'user') {
                await triggerAIResponse();
            } else {
                // Switch back to user after sending assistant message
                window.playgroundState.senderRole = 'user';
                roleToggle.querySelectorAll('.role-toggle-btn').forEach(b => {
                    b.classList.toggle('active', b.dataset.role === 'user');
                });
                messageInput.placeholder = 'Type your message...';
            }
        }
        
        window.triggerAIResponse = triggerAIResponse;

        /**
         * Load LLM configuration from backend
         */
        async function loadDefaultSettings() {
            if (defaultsLoaded) return;
            
            try {
                const response = await fetch('http://localhost:3000/api/config');
                if (!response.ok) {
                    console.warn('Failed to load LLM config, using fallback values');
                    setFallbackDefaults();
                    defaultsLoaded = true;
                    return;
                }
                const config = await response.json();
                
                const uiService = config.aiService === 'ollama' ? 'local' : config.aiService;
                
                serviceSelect.value = uiService || '';
                modelSelect.value = config.model || '';
                temperatureInput.value = config.temperature?.toString() || '';
                maxTokensInput.value = config.maxTokens?.toString() || '';
                topPInput.value = config.topP?.toString() || '';
                
                if (serviceSelect.value) {
                    const actualService = serviceSelect.value === 'local' ? 'ollama' : serviceSelect.value;
                    apiKeyInput.value = getApiKeyForService(actualService);
                    const serviceName = serviceSelect.options[serviceSelect.selectedIndex]?.text || 'service';
                    apiKeyInput.placeholder = `Enter ${serviceName} API key (optional)`;
                }
                
                updateStatusBar();
                defaultsLoaded = true;
            } catch (error) {
                console.warn('Error loading LLM config:', error);
                setFallbackDefaults();
                defaultsLoaded = true;
            }
        }

        function setFallbackDefaults() {
            serviceSelect.value = 'openai';
            modelSelect.value = 'gpt-4o-mini';
            temperatureInput.value = '0.7';
            maxTokensInput.value = '2048';
            topPInput.value = '0.95';
            updateStatusBar();
        }

        /**
         * Update the pinned system prompt component
         * @param {Object|null} message - System message object, or null if none exists
         * @param {boolean} isEditing - Whether in edit mode
         */
        function updatePinnedSystemPrompt(message, isEditing = false) {
            const systemPromptDisplay = document.getElementById('systemPromptDisplay');
            const systemPromptContent = document.getElementById('systemPromptContent');
            const systemPromptHeader = document.getElementById('systemPromptHeader');
            const systemPromptPreview = document.getElementById('systemPromptPreview');
            
            if (!systemPromptDisplay || !systemPromptContent || !systemPromptHeader) return;
            
            const text = message?.text || '';
            
            if (systemPromptPreview) {
                if (text.trim()) {
                    const preview = text.length > 60 ? text.slice(0, 60) + '...' : text;
                    systemPromptPreview.textContent = preview;
                    systemPromptPreview.className = 'system-prompt-preview';
                } else {
                    systemPromptPreview.textContent = 'None';
                    systemPromptPreview.className = 'system-prompt-preview system-prompt-empty';
                }
            }
            
            if (isEditing) {
                if (window.currentlyEditingMessageId && message && window.currentlyEditingMessageId !== message.id) {
                    if (window.saveCurrentEdit) {
                        window.saveCurrentEdit();
                    }
                }
                
                if (message) {
                    window.currentlyEditingMessageId = message.id;
                }
                
                const existingTextarea = systemPromptDisplay.querySelector('textarea');
                if (existingTextarea) {
                    systemPromptContent.style.display = 'block';
                    return;
                }
                
                systemPromptDisplay.innerHTML = '';
                const textarea = document.createElement('textarea');
                textarea.className = 'system-prompt-input-field';
                textarea.value = text;
                textarea.rows = Math.max(3, Math.min(8, text.split('\n').length || 3));
                textarea.placeholder = 'Enter system prompt...';
                
                const handleKeydown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        saveSystemPrompt(textarea.value);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelSystemPromptEdit();
                    }
                };
                
                const handleInput = () => {
                    textarea.style.height = 'auto';
                    textarea.style.height = textarea.scrollHeight + 'px';
                };
                
                textarea.addEventListener('keydown', handleKeydown);
                textarea.addEventListener('input', handleInput);
                
                systemPromptDisplay.appendChild(textarea);
                systemPromptContent.style.display = 'block';
                textarea.focus();
            } else {
                if (message && window.currentlyEditingMessageId === message.id) {
                    window.currentlyEditingMessageId = null;
                }
                
                const existingTextarea = systemPromptDisplay.querySelector('textarea');
                if (existingTextarea) {
                    existingTextarea.remove();
                }
                
                if (text.trim()) {
                    systemPromptDisplay.innerHTML = renderMarkdown(text);
                    systemPromptDisplay.className = 'system-prompt-pinned-display';
                } else {
                    systemPromptDisplay.textContent = 'Click to add system prompt...';
                    systemPromptDisplay.className = 'system-prompt-pinned-display system-prompt-empty';
                }
                
                systemPromptDisplay.style.cursor = 'pointer';
                systemPromptDisplay.addEventListener('click', function editHandler(e) {
                    e.stopPropagation();
                    editSystemPrompt();
                }, { once: true });
            }
        }
        window.updatePinnedSystemPrompt = updatePinnedSystemPrompt;
        
        /**
         * Start editing system prompt
         */
        function editSystemPrompt() {
            const systemMessage = messages.find(m => m.role === 'system');
            updatePinnedSystemPrompt(systemMessage, true);
        }
        
        /**
         * Save system prompt (creates message if needed, removes if empty)
         */
        function saveSystemPrompt(newText) {
            const trimmedText = newText.trim();
            let systemMessage = messages.find(m => m.role === 'system');
            
            if (trimmedText) {
                if (systemMessage) {
                    // Update existing
                    systemMessage.text = trimmedText;
                    systemMessage.originalText = trimmedText;
                } else {
                    // Create new
                    systemMessage = {
                        id: 'system-' + Date.now(),
                        text: trimmedText,
                        role: 'system',
                        timestamp: new Date(),
                        originalText: trimmedText
                    };
                    messages.unshift(systemMessage);
                    window.playgroundMessages = messages;
                }
            } else if (systemMessage) {
                // Remove empty system message
                const index = messages.indexOf(systemMessage);
                if (index > -1) {
                    messages.splice(index, 1);
                    window.playgroundMessages = messages;
                }
                systemMessage = null;
            }
            
            window.currentlyEditingMessageId = null;
            updatePinnedSystemPrompt(systemMessage, false);
            autoSaveConversationState();
        }
        
        /**
         * Cancel system prompt edit
         */
        function cancelSystemPromptEdit() {
            window.currentlyEditingMessageId = null;
            const systemMessage = messages.find(m => m.role === 'system');
            updatePinnedSystemPrompt(systemMessage, false);
        }

        function updateStatusBar() {
            statusService.textContent = serviceSelect.value || '—';
            statusModel.textContent = modelSelect.value || '—';
            statusMode.textContent = window.playgroundState.responseMode === 'json' ? 'JSON' : 'Text';
        }

        function handleModeToggleClick(e) {
            const button = e.target.closest('.mode-toggle-button');
            if (!button) return;
            
            const mode = button.getAttribute('data-mode');
            window.playgroundState.responseMode = mode;
            
            Array.from(modeToggle.querySelectorAll('.mode-toggle-button')).forEach((btn) => {
                btn.classList.toggle('mode-toggle-button-active', btn === button);
            });
            
            updateStatusBar();
        }

        function showUndoOption() {
            let notification = document.getElementById('undoNotification');
            if (notification) {
                notification.remove();
            }
            
            notification = document.createElement('div');
            notification.id = 'undoNotification';
            notification.className = 'undo-notification';
            notification.innerHTML = `
                <span>Action completed</span>
                <button class="undo-btn" id="undoBtn">Undo (⌘Z)</button>
            `;
            document.body.appendChild(notification);
            
            document.getElementById('undoBtn').addEventListener('click', performUndo);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }
        window.showUndoOption = showUndoOption;

        function performUndo() {
            if (window.playgroundUndoStack.length === 0) return;
            
            const undoAction = window.playgroundUndoStack.pop();
            
            if (undoAction.type === 'edit') {
                const message = messages.find(m => m.id === undoAction.messageId);
                if (message) {
                    message.text = undoAction.oldText;
                    renderMessage(message, messagesContainer, false);
                }
            } else if (undoAction.type === 'delete') {
                messages.splice(undoAction.index, 0, undoAction.message);
                renderMessage(undoAction.message, messagesContainer, false);
                
                if (emptyState) {
                    emptyState.classList.add('hidden');
                }
            }
            
            const notification = document.getElementById('undoNotification');
            if (notification) {
                notification.remove();
            }
        }

        function setSettingsOpen(isOpen) {
            if (isOpen) {
                settingsDrawer.classList.add('open');
                settingsBackdrop.classList.add('visible');
                settingsDrawer.setAttribute('aria-hidden', 'false');
            } else {
                settingsDrawer.classList.remove('open');
                settingsBackdrop.classList.remove('visible');
                settingsDrawer.setAttribute('aria-hidden', 'true');
            }
        }

        // ========================================
        // PROMPT, VERSION & CONVERSATION MANAGEMENT
        // ========================================

        const promptsList = document.getElementById('promptsList');
        const promptHeader = document.getElementById('promptHeader');
        const promptNameDisplay = document.getElementById('promptNameDisplay');
        const saveVersionButton = document.getElementById('saveVersionButton');
        const versionsContainer = document.getElementById('versionsContainer');
        const conversationsContainer = document.getElementById('conversationsContainer');
        const newPromptButton = document.getElementById('newPromptButton');

        // Initialize PromptUI
        PromptUI.init({
            promptsList: promptsList,
            promptHeader: promptHeader,
            promptNameDisplay: promptNameDisplay,
            versionsContainer: versionsContainer,
            conversationsContainer: conversationsContainer,
            saveVersionBtn: saveVersionButton,
            serviceSelect: serviceSelect,
            modelSelect: modelSelect,
            temperatureInput: temperatureInput,
            maxTokensInput: maxTokensInput,
            topPInput: topPInput,
            modeToggle: modeToggle
        });

        // Set UI callbacks
        PromptUI.setCallbacks({
            onSwitchConversation: handleSwitchConversation,
            onLoadVersion: handleLoadVersion,
            onDeleteConversation: handleDeleteConversation,
            onNewConversation: handleNewConversation
        });

        // Helper to get config from UI
        function getConfigFromUI() {
            return {
                service: serviceSelect.value,
                model: modelSelect.value,
                responseMode: window.playgroundState.responseMode,
                temperature: temperatureInput.value || '',
                maxTokens: maxTokensInput.value || '',
                topP: topPInput.value || ''
            };
        }

        /**
         * Ensure a prompt and conversation exist
         */
        function ensurePromptAndConversation() {
            if (!AppState.currentPromptId) {
                const { prompt, conversation } = createNewPrompt();
                autoSaveConversationState();
                refreshUI();
            }
        }

        /**
         * Auto-save current conversation state
         */
        function autoSaveConversationState() {
            if (!AppState.activeConversationId) return;
            const config = getConfigFromUI();
            autoSaveConversation(messages, config);
            // Refresh conversation list to update message counts
            PromptUI.refreshConversations();
        }
        window.autoSaveConversationState = autoSaveConversationState;

        /**
         * Load messages from data source
         */
        function loadMessagesFromData(msgData) {
            messages = [];
            
            if (msgData && Array.isArray(msgData)) {
                msgData.forEach((m) => {
                    // Skip empty system messages (legacy cleanup)
                    if (m.role === 'system' && !m.text?.trim()) {
                        return;
                    }
                    messages.push({
                        id: m.id || (Date.now() + Math.random().toString(16).slice(2)),
                        text: m.text || '',
                        role: m.role,
                        timestamp: m.timestamp ? new Date(m.timestamp) : new Date(),
                        originalText: m.text || ''
                    });
                });
            }

            window.playgroundMessages = messages;
        }

        /**
         * Render messages to UI
         */
        function renderMessagesToUI() {
            messagesContainer.innerHTML = '';
            
            if (messages.length === 0 || (messages.length === 1 && messages[0].role === 'system' && !messages[0].text.trim())) {
                messagesContainer.appendChild(emptyState);
                emptyState.classList.remove('hidden');
            } else {
                emptyState.classList.add('hidden');
                
                // Check if conversation came from a version (to show separator)
                const conversation = AppState.getActiveConversation();
                const versionOrigin = conversation?.origin?.type === 'version' ? conversation.origin : null;
                
                // Get versionMessageCount, calculating from version if not stored (backwards compatibility)
                let versionMessageCount = versionOrigin?.versionMessageCount || 0;
                if (versionOrigin && !versionMessageCount && versionOrigin.sourceId) {
                    const version = VersionStore.get(versionOrigin.sourceId, AppState.currentPromptId);
                    if (version) {
                        versionMessageCount = (version.messages || []).filter(m => m.role !== 'system').length;
                    }
                }
                
                // Count non-system messages as we render
                let nonSystemCount = 0;
                let separatorInserted = false;
                
                messages.forEach((message) => {
                    // Insert separator after the last version message (before first new message)
                    if (message.role !== 'system') {
                        nonSystemCount++;
                        
                        // If we just passed the version boundary and there are more messages, add separator
                        if (!separatorInserted && versionOrigin && nonSystemCount === versionMessageCount + 1 && versionMessageCount > 0) {
                            const separator = document.createElement('div');
                            separator.className = 'version-separator';
                            separator.setAttribute('role', 'separator');
                            separator.setAttribute('aria-label', `Saved in ${versionOrigin.sourceId}`);
                            separator.innerHTML = `<span class="version-separator-label">Saved in ${versionOrigin.sourceId}</span>`;
                            messagesContainer.appendChild(separator);
                            separatorInserted = true;
                        }
                    }
                    
                    renderMessage(message, messagesContainer, false);
                });
            }

            const systemMessage = messages.find(m => m.role === 'system');
            updatePinnedSystemPrompt(systemMessage, false);
        }

        /**
         * Handle loading a prompt
         */
        function handleLoadPrompt(promptId) {
            // Save current conversation before switching
            autoSaveConversationState();
            
            const state = loadPrompt(promptId);
            if (!state) return;

            // Load the active conversation's data
            if (state.activeConversation) {
                loadMessagesFromData(state.activeConversation.messages);
                PromptUI.applyConfig(state.activeConversation.config, updateStatusBar);
            } else {
                loadMessagesFromData([]);
            }
            
            renderMessagesToUI();
            refreshUI();
        }

        /**
         * Handle switching to a different conversation
         */
        function handleSwitchConversation(conversationId) {
            // Save current conversation before switching
            autoSaveConversationState();
            
            const conversation = switchToConversation(conversationId);
            if (!conversation) return;

            loadMessagesFromData(conversation.messages);
            PromptUI.applyConfig(conversation.config, updateStatusBar);
            renderMessagesToUI();
            refreshUI();
        }

        /**
         * Handle loading a version into a new conversation
         */
        function handleLoadVersion(versionId) {
            // Save current conversation before switching
            autoSaveConversationState();
            
            const conversation = loadVersionIntoNewConversation(versionId);
            if (!conversation) return;

            loadMessagesFromData(conversation.messages);
            PromptUI.applyConfig(conversation.config, updateStatusBar);
            renderMessagesToUI();
            refreshUI();
        }

        /**
         * Handle creating a new conversation
         */
        function handleNewConversation() {
            // Save current conversation before creating new
            autoSaveConversationState();
            
            const conversation = createNewConversation();
            if (!conversation) return;

            loadMessagesFromData([]);
            renderMessagesToUI();
            refreshUI();
        }

        /**
         * Handle deleting a conversation
         */
        function handleDeleteConversation(conversationId) {
            const state = AppState.getFullState();
            const isActive = conversationId === state.activeConversationId;
            
            if (isActive && state.conversations.length === 1) {
                if (!confirm('Delete this conversation? A new empty conversation will be created.')) {
                    return;
                }
            }
            
            const newState = deleteConversation(conversationId);
            
            // If we deleted the active conversation, load the new active one
            if (isActive && newState.activeConversation) {
                loadMessagesFromData(newState.activeConversation.messages);
                PromptUI.applyConfig(newState.activeConversation.config, updateStatusBar);
                renderMessagesToUI();
            }
            
            refreshUI();
        }

        /**
         * Handle deleting a prompt
         */
        function handleDeletePrompt(promptId) {
            const prompts = PromptStore.list();
            const msg = prompts.length === 1
                ? 'Delete this prompt? A new empty prompt will be created.'
                : 'Delete this prompt and all its versions and conversations?';
            if (!confirm(msg)) return;
            
            const wasActive = promptId === AppState.currentPromptId;
            PromptStore.delete(promptId);
            
            if (wasActive) {
                const remaining = PromptStore.list();
                if (remaining.length > 0) {
                    handleLoadPrompt(remaining[0].id);
                } else {
                    handleCreateNewPrompt();
                }
            } else {
                refreshUI();
            }
        }

        /**
         * Handle deleting a version
         */
        function handleDeleteVersion(versionId) {
            if (!confirm(`Delete ${versionId}?`)) return;
            const promptId = AppState.currentPromptId;
            if (promptId) {
                VersionStore.delete(versionId, promptId);
                refreshUI();
            }
        }

        /**
         * Branch from a specific message (global function called from messages.js)
         * Creates a new conversation with messages up to and including the specified message
         */
        function branchAtMessage(messageId) {
            // Save current conversation first
            autoSaveConversationState();
            
            const currentConversationId = AppState.activeConversationId;
            if (!currentConversationId) return;
            
            const conversation = branchConversation(currentConversationId, messageId);
            if (!conversation) return;

            loadMessagesFromData(conversation.messages);
            PromptUI.applyConfig(conversation.config, updateStatusBar);
            renderMessagesToUI();
            refreshUI();
        }
        // Expose globally for messages.js
        window.branchAtMessage = branchAtMessage;

        /**
         * Handle saving as a new version
         */
        function handleSaveAsVersion() {
            // Check if there's any content (including system prompt)
            const hasContent = messages.some(m => m.text && m.text.trim());
            if (!hasContent) {
                alert('Add some content before saving a version.');
                return;
            }

            // Ensure prompt and conversation exist
            ensurePromptAndConversation();

            // Save current state first
            autoSaveConversationState();

            // Show modal
            PromptUI.showSaveVersionModal((notes) => {
                const version = saveConversationAsVersion(notes);
                if (version) {
                    // Re-render messages to update/remove separator (all messages are now part of the version)
                    renderMessagesToUI();
                    refreshUI();
                }
            });
        }

        /**
         * Handle creating a new prompt
         */
        function handleCreateNewPrompt() {
            // Save current conversation before switching
            autoSaveConversationState();
            
            // Create new prompt with initial conversation
            const { prompt, conversation } = createNewPrompt();
            
            // Reset messages
            messages = [];
            window.playgroundMessages = messages;
            
            // Save initial state
            autoSaveConversationState();
            
            renderMessagesToUI();
            refreshUI();
        }

        /**
         * Refresh all UI components
         */
        function refreshUI() {
            PromptUI.refreshPromptsList(handleLoadPrompt, handleDeletePrompt);
            PromptUI.refreshVersionsAndConversations(handleDeleteVersion);
            PromptUI.updatePromptHeader();
        }

        // ========================================
        // EVENT LISTENERS
        // ========================================

        sendButton.addEventListener('click', sendMessage);
        
        roleToggle.addEventListener('click', (e) => {
            const btn = e.target.closest('.role-toggle-btn');
            if (!btn) return;
            const role = btn.dataset.role;
            window.playgroundState.senderRole = role;
            roleToggle.querySelectorAll('.role-toggle-btn').forEach(b => {
                b.classList.toggle('active', b.dataset.role === role);
            });
            messageInput.placeholder = role === 'assistant' ? 'Type assistant response...' : 'Type your message...';
        });
        
        messageInput.addEventListener('input', () => autoResizeTextarea(messageInput));
        
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        modeToggle.addEventListener('click', handleModeToggleClick);
        
        document.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                if (window.playgroundUndoStack.length > 0) {
                    performUndo();
                }
            }
        });

        settingsToggleButton.addEventListener('click', () => {
            const isOpen = settingsDrawer.classList.contains('open');
            setSettingsOpen(!isOpen);
        });

        settingsCloseButton.addEventListener('click', () => setSettingsOpen(false));
        settingsBackdrop.addEventListener('click', () => setSettingsOpen(false));

        serviceSelect.addEventListener('change', () => {
            updateStatusBar();
            const service = serviceSelect.value;
            const actualService = service === 'local' ? 'ollama' : service;
            if (actualService) {
                apiKeyInput.value = getApiKeyForService(actualService);
                const serviceName = serviceSelect.options[serviceSelect.selectedIndex]?.text || 'service';
                apiKeyInput.placeholder = `Enter ${serviceName} API key (optional)`;
            } else {
                apiKeyInput.value = '';
                apiKeyInput.placeholder = 'Select a service first';
            }
        });
        modelSelect.addEventListener('input', updateStatusBar);
        
        let apiKeySaveTimeout;
        apiKeyInput.addEventListener('input', () => {
            clearTimeout(apiKeySaveTimeout);
            apiKeySaveTimeout = setTimeout(() => {
                const service = serviceSelect.value;
                const actualService = service === 'local' ? 'ollama' : service;
                if (actualService) {
                    saveApiKey(actualService, apiKeyInput.value);
                }
            }, 500);
        });
        
        const systemPromptHeader = document.getElementById('systemPromptHeader');
        const systemPromptContent = document.getElementById('systemPromptContent');
        const systemPromptToggle = document.getElementById('systemPromptToggle');
        
        if (systemPromptHeader && systemPromptContent && systemPromptToggle) {
            systemPromptHeader.addEventListener('click', (e) => {
                if (e.target.closest('.system-prompt-pinned-display')) return;
                
                const isExpanded = systemPromptContent.style.display !== 'none';
                systemPromptContent.style.display = isExpanded ? 'none' : 'block';
                systemPromptToggle.textContent = isExpanded ? '▼' : '▲';
            });
        }
        
        if (newPromptButton) {
            newPromptButton.addEventListener('click', handleCreateNewPrompt);
        }

        if (saveVersionButton) {
            saveVersionButton.addEventListener('click', handleSaveAsVersion);
        }

        if (promptNameDisplay) {
            promptNameDisplay.addEventListener('blur', () => {
                const newName = promptNameDisplay.textContent.trim();
                if (!newName || !AppState.currentPromptId) return;

                if (PromptStore.update(AppState.currentPromptId, { name: newName })) {
                    PromptUI.refreshPromptsList(handleLoadPrompt);
                }
            });

            promptNameDisplay.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    promptNameDisplay.blur();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    const prompt = AppState.getCurrentPrompt();
                    if (prompt) {
                        promptNameDisplay.textContent = prompt.name;
                    }
                    promptNameDisplay.blur();
                }
            });
        }

        window.addEventListener('beforeunload', () => {
            autoSaveConversationState();
        });

        setInterval(() => {
            autoSaveConversationState();
        }, 30000);
        
        document.addEventListener('mousedown', (e) => {
            if (!window.currentlyEditingMessageId) return;
            
            const clickedTextarea = e.target.closest('textarea');
            if (clickedTextarea && (
                clickedTextarea.classList.contains('message-edit-textarea') ||
                clickedTextarea.classList.contains('system-prompt-input-field')
            )) {
                return;
            }
            
            const target = e.target;
            const isInteractive = target.tagName === 'BUTTON' ||
                                 target.tagName === 'A' ||
                                 target.tagName === 'INPUT' ||
                                 target.tagName === 'SELECT' ||
                                 target.closest('.input-field') ||
                                 target.closest('.send-button') ||
                                 target.closest('.settings-drawer') ||
                                 target.closest('.message-action-btn') ||
                                 target.closest('button') ||
                                 target.closest('a') ||
                                 target.closest('.system-prompt-pinned-header');
            
            if (isInteractive) {
                return;
            }
            
            setTimeout(() => {
                if (window.saveCurrentEdit && window.currentlyEditingMessageId) {
                    window.saveCurrentEdit();
                }
            }, 0);
        });

        // ========================================
        // INITIALIZATION
        // ========================================

        loadDefaultSettings().then(() => {
            const systemMessage = messages.find(m => m.role === 'system');
            updatePinnedSystemPrompt(systemMessage, false);
            refreshUI();
            messageInput.focus();
        });
    </script>
</body>
</html>
